<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <title>Document</title>
</head>
<body>
  <header>
    <h1>Relatório Trabalho 1 de Redes II</h1>
    <p>Eduardo Vudala</p>
    <p>Gabriel Lüders</p>
  </header>
  <section>
    <div>
      <h2>1. Introdução</h2>
      <p>
        Este relatório tem como objetivo apresentar o trabalho realizado na disciplina de Redes II, 
        ministrada pelo professor Elias P. Duarte Jr., no semestre 2022/2.
      </p>
      <p>
        <br>
        O trabalho consiste em implementar um canhão UDP com o intuito de medir a taxa aproximada
        de perda de pacote em uma rede, além de verificar se mensagens são entregues fora de ordem.
      </p>
    </div>
    <div>
      <h2>2. Implementação</h2>
      <p>
        O trabalho foi implementado em C++ e consiste em bibliotecas para o cliente, servidor e
        o tipo de mensagem sendo transmitida, além de duas mains, uma para o cliente e outra
        para o servidor, que utilizam a API de sockets do C++ para comunicar datagramas UDP.
      </p>

      <h3>2.1. Mensagem</h3>
      <p>
        A mensagem é uma struct composta por um ID de mensagem, um ID de cliente (que é basicamente
        o PID do processo enviando aquele datagrama) e uma string de 100 caracteres:
      </p>

      <div class="imgWrapper">
        <img src="images/message.png" alt="estrutura das mensagens">
      </div>

      <p>
        As mensagens são enviadas em um datagrama UDP via função sendto e recebidas pela função
        recvfrom da API de sockets do C++. 
      </p>
      
      <h3>2.2. Cliente</h3>
      <p>
        O cliente é composto por um gerenciador responsável por controlar uma série de clientes filhos,
        gerados via fork, que são responsáveis por enviar mensagens para o servidor. 
        Cada filho envia o mesmo número de mensagens ao servidor, com IDs de mensagem sequenciais
        - de 1 até o número máximo enviado por cada um -, de maneira concorrente.
      </p>
      <p>
        <br>
        Cada fork é dado por uma estrutura constituida por um descritor de socket por onde realizar
        a comunicação com o servidor, o endereço do servidor, uma entendidade de host, 
        uma string que representa o nome do servidor e uma main responsável pela comunicação:
      </p>
      
      <div class="imgWrapper">
        <img src="images/client.png" alt="estutura do cliente">
      </div>
      
      <p>
        Ao passo que o gerenciador é uma main própria responsável por gerar os filhos e 
        imprimir os relatórios após todos os filhos terminarem de rodar.
      </p>
      
      <h3>2.3. Servidor</h3>
      <p>
        O servidor é um servidor UDP comum que recebe mensagens da forma apresentada acima, 
        trata essas mensagens, responde cada uma e, após um timeout de 5 segundos, imprime
        os relatórios de mensagens recebidas, perdidas e fora de ordem.
      </p>

      <p>
        <br>
        A estrutura do servidor é dada por um descritor de socket, um buffer para a mensagem
        recebida, o endereço do servidor, o endereço do cliente, uma entidade de host, uma string
        que representa o nome do servidor, um booleano que indica se o servidor deve imprimir 
        mensagens na tela, o total de clientes conversando, o total de mensagens esperadas, o total
        de mensagens perdidas e o total de mensagens fora de ordem. Além disso, também
        possui uma esturtura que representa as informações das mensagens para tratamento 
        e produção de relatórios e um booleano que indica que o alarme do timeout foi disparado:
      </p>

      <div class="serverImages">
        <div class="imgWrapper">
          <img src="images/server.png" alt="estutura do servidor">
        </div>
        <div>
          <img src="images/reportInfo.png" alt="estutura do relatório">
        </div>
      </div>

      <h3>2.4. Comunicação</h3>
      <p>
        Inicialmente, o gerenciador e o servidor realizam um handshake no qual a quantidade de 
        clientes a serem abertos e a quantidade de mensagens por cliente são enviadas ao servidor.
        Após, o gerente faz o fork de todos os clientes que iniciam comunicação com o servidor 
        imediamente.
        <br><br>
        Cada cliente envia X mensagens para o servidor com um ID de mensagem sequencial, 
        incrementado um a um. O servidor recebe as mensagens, trata e responde cada uma. Os clientes,
        contudo, não esperam as respostas do servidor para enviar a próxima mensagem. Portanto, a 
        resposta que o servidor realiza é apenas para simular o load de uma comunicação real, além
        dos processamentos já feitos.
      </p>
      <p>
        <br>
        Quando todos os clientes terminam de enviar suas mensagens, o servidor finaliza o 
        loop de escuta após um timeout de 5 segundos. Em seguida, imprime os relatórios e 
        escreve os arquivos utilizados para tratamentos finais e geração de gráficos. 
      </p>
      <p>
        <br>
        No mais, as mensagens são enviadas utilizando sendTo e recebidas utilizando recvFrom,
        como o objetivo é medir a taxa de perda de pacotes, não há reenvio de mensagens nem
        confirmação de recebimento:  
      </p>

      <div class="communication">
        <div class="imgWrapper serverSend">
          <img src="images/sendToClient.png" alt="envio para o cliente do server">
        </div>
        <div class="imgWrapper clientSend">
          <img src="images/sendtoServer.png" alt="envio do cliente para o server">
        </div>
        <div class="imgWrapper receive">
          <img src="images/receiveFromClient.png" alt="recebimento pelo servidor">
        </div>
      </div>
    </div>
    <div>
      <h2>3. Testes</h2>
      <p>
        Os testes feitos foram realizados com as máquias h29 e h30 do laboratório 1/2 do 
        Dinf, assim como nas máquinas pessoais dos integrantes do grupo.
      </p>
      <p>
        <br>
        Os testes constituem em uma bateria de comunicações com 
        diferentes quantidades de clientes e mensagens por clientes, além de uma segunda
        bateria de testes com um número fixo de clientes = 1 e variação na 
        quantidade de mensagens. Fizemos dessa maneira com o objetivo de sermos exaustivos
         e não deixar dúvidas sobre os resultados.
        <br><br>
        Há um script run.sh que automatiza a execução nas máquinas pessoais e que demonstra
        o que foi feito nas do laboratório. Logs de execução e os arquivos fonte estão 
        disponíveis abaixo. 
      </p>
    </div>
    <div>
      <h2>4. Resultados</h2>
      <p>
        Os resultados obtidos foram curiosos. A equipe percebeu que a comunicação entre duas
        máquinas diferentes e a comunicação nas máquinas pessoais dos integrantes do grupo
        não apresentaram resutados muito diferentes.
        <br><br>
        Apesar de a comunicação nas máquinas pessoais nem usar a placa de rede, notamos uma grande
        taxa de perda de pacotes quando o número de clientes era muito alto ou muitas mensagens
        estavam sendo enviadas por apenas um cliente. O mesmo ocorreu nas máquinas do laboratório,
        levando o grupo a acreditar que o IP não é responsável pelas perdas, mas sim a saturação
        do buffer UDP.
        <br><br>
        Além disso, a dupla também notou que não houve entrega de mensagens fora de ordem, o que 
        pode ser explicado pela curta distância e portanto baixa quantidade de hops entre as máquinas.
      </p>
      <p>
        <br>
        Agora, deixando as similaridades de lado, vamos a discussão dos resultados obtidos nas
        máquinas do laboratório.
      </p>

      <h3>4.1. Extração</h3>
      <p>
        Tanto cliente quanto servidor apresentam relatórios básicos de execução. Os clientes mostram
        quantas mensagens enviaram e indicam se tudo ocorreu como esperado, ao passo que o servidor
        mostra as taxas de perda de pacotes, quantas mensagens foram recebidas por cada cliente e
        quantas mensagens foram recebidas fora de ordem. Abaixo temos um exemplo dos relatórios
        básicos em tela para uma comunicação entre 3 clientes e 1 servidor com 5 mensagens por cliente:   
      </p>

      <div class="serverImages">
        <div class="imgWrapper">
          <img src="images/h29basic.png"  alt="relatório básico do cliente">
        </div>
        <div class="imgWrapper">
          <img src="images/h30basic.png" alt="relatório básico do servidor">
        </div>
      </div>

      <p>
        Agora um exemplo um pouco maior, com 8 clientes e 500 mensagens por cliente, porém mostrando 
        só o footer dos relatórios:
      </p>
      
      <div class="serverImages">
        <div class="imgWrapper">
          <img src="images/h29footer.png" alt="relatório extendido do cliente">
        </div>
        <div class="imgWrapper">
          <img src="images/h30footer.png" alt="relatório extendido do servidor">
        </div>
      </div>
      
      <p>
        <br>
        Além disso, o servidor também escreve alguns arquivos que são utilizados para geração de 
        gráficos e análise dos resultados obtidos. Esses arquivos contém informações sobre
        toda a bateria de testes realizada, permitindo uma análise mais geral dos resultados e podem 
        ser encontrados na aba de arquivos fonte.
      </p>

      <h3>4.2. Número de clientes fixo = 1</h3>
      <p>
        A primeira bateria de testes foi feita com um número fixo de clientes = 1 e variação na 
        quantidade de mensagens. O objetivo era verificar se a taxa de perda de pacotes aumentava
        com o aumento da quantidade de mensagens. 
        <br><br>
        Rodamos com um cliente para um intervalo de 1000 a 4e+06:
        
      </p>

      <div class="imgWrapper">
        <img src="images/totalClients.png"  alt="input teste 1">
      </div>
      
      <p>
        O
        teste foi repetido 4 vezes e a média de perda de pacotes foi calculada cada vez e anotada 
        nos gráficos:
      </p>

      <div class="graphs">
          <img src="graphs/loss-rate-vs-total-messages1.png" alt="gráfico de 1 cliente 1">
          <img src="graphs/loss-rate-vs-total-messages2.png" alt="gráfico de 1 cliente 2">
          <img src="graphs/loss-rate-vs-total-messages3.png" alt="gráfico de 1 cliente 3">
          <img src="graphs/loss-rate-vs-total-messages4.png" alt="gráfico de 1 cliente 4">
      </div>

      <p>
        Com uma taxa média final de 33.43% de perda de pacotes, o grupo concluiu que a taxa se mantém
        num intervalo pouco variável a partir do momento que o número de mensagens é grande o suficiente para
        causar a saturação do buffer UDP e portanto só depende da velocidade com que o servidor consegue
        processar as mensagens com relação a velocidade que o cliente está enviando e não da quantidade de
        mensagens em si, ao menos quando temos apenas um cliente enviando mensagens.
      </p>
    </div>
  </section>
</body>
</html>